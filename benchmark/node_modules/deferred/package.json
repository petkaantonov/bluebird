{
  "name": "deferred",
  "version": "0.6.6",
  "description": "Modular and fast Promises implementation",
  "keywords": [
    "async",
    "asynchronous",
    "deferred",
    "flow",
    "future",
    "futures",
    "promise",
    "promises",
    "continuations"
  ],
  "author": {
    "name": "Mariusz Nowak",
    "email": "medikoo+deferred@medikoo.com",
    "url": "http://www.medikoo.com/"
  },
  "main": "lib",
  "repository": {
    "type": "git",
    "url": "git://github.com/medikoo/deferred.git"
  },
  "bugs": {
    "url": "https://github.com/medikoo/deferred/issues",
    "email": "medikoo+deferred@medikoo.com"
  },
  "engines": {
    "node": ">=0.4"
  },
  "dependencies": {
    "es5-ext": "~0.9.2",
    "event-emitter": "~0.2.2",
    "next-tick": "0.1.x"
  },
  "scripts": {
    "test": "node ./node_modules/tad/bin/tad lib"
  },
  "devDependencies": {
    "tad": "~0.1.19"
  },
  "licence": "MIT",
  "optionalDependencies": {},
  "readme": "# Deferred\n## Modular and fast Promises implementation for JavaScript\n\n_Implementation originally inspired by Kris Kowal's [Q](https://github.com/kriskowal/q)_\n\nDeferred is complete, __[one of the fastest](#performance)__ and natural promise implementation in JavaScript, with Deferred you can write __[clear maintainable code](#promises-approach)__ that takes maximum out of asynchronicity, in fact due to multi-dimensional nature of promises ( __[chaining](#chaining)__ and __[nesting](#nesting)__) you're forced to program declaratively.  \n\nWith Deferred you also can: __[Process collections](#processing-collections)__ of deferred calls. __[Handle Node.js asynchronous functions](#promisify---working-with-asynchronous-functions-as-we-know-them-from-nodejs)__. __[Limit concurrency](#limiting-concurrency)__ of scheduled tasks. __[Emit progress events](#progress-and-other-events)__ or __[stream results partially](#streaming-data-partially)__ on the go.  \n\nIn the end you may debug your flow by __[tracking unresolved promises](#monitoring-unresolved-promises)__ or gathering __[usage statistics](#usage-statistics)__.\n\n_For good insight into promise/deferred concept and in general asynchronous programming see also slides from meetjs summit presentation: [Asynchronous JavaScript](http://www.medikoo.com/asynchronous-javascript/)_\n\n__If you need help with deferred, please ask on dedicated mailing list: [deferred-js@googlegroups.com](https://groups.google.com/forum/#!forum/deferred-js)__\n\n## Comparision with callback style\n\nLet's take an example script that concatenates all JavaScript files in a given directory and saves it to lib.js.\n\n### Plain Node.js, callbacks approach\n\n```javascript\nvar fs = require('fs');\n\nvar readdir = fs.readdir;\nvar readFile = fs.readFile;\nvar writeFile = fs.writeFile;\n\n// Read all filenames in given path\nreaddir(__dirname, function (err, files) {\n\tvar result, waiting;\n\tif (err) {\n\t\t// if we're unable to get file listing throw error\n\t\tthrow err;\n\t}\n\n\t// Filter *.js files and generated lib.js\n\tfiles = files.filter(function (file) {\n\t\treturn (file.slice(-3) === '.js') && (file !== 'lib.js');\n\t});\n\n\t// Read content of each file\n\twaiting = 0;\n\tresult = [];\n\tfiles.forEach(function (file, index) {\n\t\t++waiting;\n\t\treadFile(file, function (err, content) {\n\t\t\tif (err) {\n\t\t\t\t// We were not able to read file content, throw error\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tresult[index] = content;\n\n\t\t\tif (!--waiting) {\n\t\t\t\t// Got content of all files\n\t\t\t\t// Concatenate into one string and write into lib.js\n\t\t\t\twriteFile(__dirname + '/lib.js', result.join(\"\\n\"), function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t// We cannot write lib.js file, throw error\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n});\n```\n\n### Implementation with promises:\n\n```javascript\nvar promisify = require('deferred').promisify;\nvar fs = require('fs');\n\n// Convert node.js async functions, into ones that return a promise\nvar readdir = promisify(fs.readdir);\nvar readFile = promisify(fs.readFile, 1); // Restrict arity to 1 + callback\nvar writeFile = promisify(fs.writeFile);\n\nwriteFile(__dirname + '/lib.js',\n\t// Read all filenames in given path\n\treaddir(__dirname)\n\n\t// Filter *.js files and generated lib.js\n\t.invoke('filter', function (file) {\n\t\treturn (file.slice(-3) === '.js') && (file !== 'lib.js');\n\t})\n\n\t// Read content of all files\n\t.map(readFile)\n\n\t// Concatenate files content into one string\n\t.invoke('join', '\\n')\n\n).done(); // If there was any error on the way throw it\n```\n\n## Examples\n\nSee [examples folder](examples) for a demonstration of promises usage in some other real world cases.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n\t$ npm install deferred\n\n### Browser\n\nBrowser bundle can be easily created with help of [modules-webmake](https://github.com/medikoo/modules-webmake). Assuming that you have latest [Node.js](http://nodejs.org/) and [Git](http://git-scm.com/) installed, following will work in command shell of any system (Linux/MacOS/Windows):\n\n```\n$ npm install -g webmake\n$ git clone git://github.com/medikoo/deferred.git\n$ cd deferred\n$ npm install\n$ cd ..\n$ webmake --name=deferred deferred/lib/index.js deferred.js\n```\n\nLast command bundles deferred with all it's functionalities, but you may need just a subset, you can have that by addressing specific modules directly, e.g. with following you will build just core functionality with map extension:\n\n```\n$ webmake --name=deferred --include=deferred/lib/ext/promise/map.js deferred/lib/deferred.js deferred.js\n```\n\nIf you work with AMD modules, use _amd_ option, so generated bundle is one:\n\n```\n$ webmake --amd deferred/lib/index.js deferred.js\n```\n\nTo explicitly name AMD module pass _name_ option:\n\n```\n$ webmake --name=deferred --amd deferred/lib/index.js deferred.js\n```\n\n\n\n_Mind that deferred relies on some ECMAScript5 features, so for older browsers you need to load as well [es5-shim](https://github.com/kriskowal/es5-shim)_\n\n## Deferred/Promise concept\n\n### Deferred\n\nFor work that doesn't return immediately (asynchronous) you may create deferred object. Deferred holds both `resolve` and `promise` objects. Observers interested in value are attached to `promise` object, with `resolve` we resolve promise with an actual value. In common usage `promise` is returned to the world and `resolve` is kept internally\n\nLet's create `delay` function decorator:\n\n```javascript\nvar deferred = require('deferred');\n\nvar delay = function (fn, timeout) {\n\treturn function () {\n\t\tvar def = deferred(), self = this, args = arguments;\n\n\t\tsetTimeout(function () {\n\t\t\tdef.resolve(fn.apply(self, args));\n\t\t}, timeout);\n\n\t\treturn def.promise;\n\t};\n};\n\nvar delayedAdd = delay(function (a, b) {\n\treturn a + b;\n}, 100);\n\nvar resultPromise = delayedAdd(2, 3);\n\nconsole.log(deferred.isPromise(resultPromise)); // true\n\nresultPromise(function (value) {\n\t// Invoked after 100 milliseconds\n\tconsole.log(value); // 5\n});\n```\n\n### Promise\n\nPromise is an object that represents eventual value which may already be available or is expected to be available in a future. Promise may succeed (fulfillment) or fail (rejection). Promise can be resolved only once.  \nIn `deferred` (and most of the other promise implementations) you may listen for the value by passing observers to `then` function:\n\n```javascript\npromise.then(onsuccess, onfail);\n```\n\nIn __deferred__ promise is really a `then` function, so you may use promise _function_ directly:\n\n```javascript\npromise === promise.then; // true\npromise(onsuccess, onfail);\n```\n\n__If you want to keep clear visible distinction between promises and other object I encourage you to always use `promise.then` notation.__\n\nBoth callbacks `onsuccess` and `onfail` are optional. They will be called only once and only either `onsuccess` or `onfail` will be called.\n\n#### Chaining\n\nPromises by nature can be chained. `promise` function returns another promise which is resolved with a value returned by a callback function:\n\n```javascript\ndelayedAdd(2, 3)(function (result) {\n\treturn result * result\n})(function (result) {\n\tconsole.log(result); // 25\n});\n```\n\nIt's not just functions that promise function can take, it can be other promises or any other JavaScript value (with exception of `null` or `undefined` which will be treated as no value). Going that way you may override result of a promise chain with specific value.\n\n#### Nesting\n\nPromises can be nested. If a promise resolves with another promise, it's not really resolved. It's resolved only when final promise is resolved with a real value:\n\n```javascript\nvar def = deferred();\ndef.resolve(delayedAdd(2, 3)); // Resolve promise with another promise\ndef.promise(function (result) {\n\tconsole.log(5); // 5;\n});\n```\n\n#### Error handling\n\nErrors in promises are handled with separate control flow, that's one of the reasons why code written with promises is more readable and maintainable than when using callbacks approach.\n\nA promise resolved with an error (rejected), propagates its error to all promises that depend on this promise (e.g. promises initiated by adding observers).  \nIf observer function crashes with error or returns error, its promise is rejected with the error.\n\nTo handle error, pass dedicated callback as second argument to promise function:\n\n```javascript\ndelayedAdd(2, 3)(function (result) {\n\tthrow new Error('Error!')\n})(function () {\n\t// never called\n}, function (e) {\n\t// handle error;\n});\n```\n\n#### Ending chain\n\nTo expose the errors that are not handled, end promise chain with `.done()`, then error that broke the chain will be thrown:\n\n```javascript\ndelayedAdd(2, 3)\n(function (result) {\n\tthrow new Error('Error!')\n})(function (result) {\n\t// never executed\n})\n.done(); // throws error!\n```\n\n__It's important to end your promise chains with `done` otherwise eventual ignored errors will not be exposed__.  \n\nSignature of `done` function is same as for `then` (or promise itself)\n\n`done` is aliased with `end` function, however `end` will be removed with introduction of v0.7 release.\n\n```javascript\npromise(function (value) {\n\t// process\n}).done(function (result) {\n\t// process result\n}, function (err) {\n\t// handle error\n});\n```\n\nAnd as with `then` either callback can be provided. If callback for error was omitted, eventual error will be thrown.\n\n#### Creating resolved promises\n\nYou may create initially resolved promises.\n\n```javascript\nvar promise = deferred(1);\n\npromise(function (result) {\n\tconsole.log(result); // 1;\n});\n```\n\n## Promisify - working with asynchronous functions as we know them from Node.js\n\nThere is a known convention (coined by Node.js) for working with asynchronous calls. An asynchronous function receives a callback argument which handles both eventual error and expected value:\n\n```javascript\nvar fs = require('fs');\n\nfs.readFile(__filename, 'utf-8', function (err, content) {\n\tif (err) {\n\t\t// handle error;\n\t\treturn;\n\t}\n\t// process content\n});\n```\n\nIt's not convenient to work with both promises and callback style functions. When you decide to build your flow with promises __don't mix both concepts, just `promisify` asynchronous functions so they return promises instead__.\n\n```javascript\nvar deferred = require('deferred')\n\t, fs = require('fs')\n\n\t, readFile = deferred.promisify(fs.readFile);\n\nreadFile(__filename, 'utf-8')(function (content) {\n\t// process content\n}, function (err) {\n\t// handle error\n});\n```\n\n`promisify` accepts also second argument, through which we may specify length of arguments that function takes (not counting callback argument), it may be handy if there's a chance that unexpected arguments will be passed to function (e.g. Array's `forEach` or `map`)\n\n`promisify` also takes care of input arguments. __It makes sure that all arguments that are to be passed to asynchronous function are first resolved.__\n\n## Grouping promises\n\nWhen we're interested in results of more than one promise object we may group them into one promise with `deferred` function:\n\n```javascript\ndeferred(delayedAdd(2, 3), delayedAdd(3, 5), delayedAdd(1, 7))(function (result) {\n\tconsole.log(result); // [5, 8, 8]\n});\n```\n\n## Processing collections\n\n### Map\n\nIt's analogous to Array's map, with that difference that it returns promise (of an array) that would be resolved when promises for all items are resolved. Any error that would occur will reject the promise and resolve it with same error.\n\nIn following example we take content of each file found in an array:\n\n```javascript\nvar readFile = deferred.promisify(fs.readFile);\n\ndeferred.map(filenames, function (filename) {\n\treturn readFile(filename, 'utf-8');\n})(function (result) {\n\t// result is an array of file's contents\n});\n```\n\n`map` is also available directly on a promise object, so we may invoke it directly on promise of a collection.\n\nLet's try again previous example but this time instead of relying on already existing filenames, we take list of files from current directory:\n\n```javascript\nvar readdir = deferred.promisify(fs.readdir);\nvar readFile = deferred.promisify(fs.readFile);\n\nreaddir(__dirname).map(function (filename) {\n\treturn readFile(filename, 'utf-8');\n})(function (result) {\n\t// result is an array of file's contents\n});\n```\n\nThis function is available also as an extension on promise object.\n\n__See [limiting concurrency](#limiting-concurrency) section for info on how to limit maximum number of concurrent calls in `map`__\n\n### Reduce\n\nIt's same as Array's reduce with that difference that it calls callback only after previous accumulated value is resolved, this way we may accumulate results of collection of promises or invoke some asynchronous tasks one after another.\n\n```javascript\ndeferred.reduce([delayedAdd(2, 3), delayedAdd(3, 5), delayedAdd(1, 7)], function (a, b) {\n\treturn delayedAdd(a, b);\n})\n(function (result) {\n\tconsole.log(result); // 21\n});\n```\n\nThis function is available also as an extension on promise object.\n\n### Some\n\nPromise aware Array's some. Process collection one after another and stop when first item matches your criteria\n\n```javascript\ndeferred.some([filename1, filename2, filename3], function (a) {\n\treturn readFile(filename, 'utf8', function (data) {\n\t\tif (data.indexOf('needle')) {\n\t\t\t// Got it! Stop further processing\n\t\t\treturn true;\n\t\t}\n\t});\n});\n```\n\nThis function is available also as an extension on promise object.\n\n## Limiting concurrency\n\nThere are cases when we don't want to run too many tasks simultaneously. Like common case in Node.js when we don't want to open too many file descriptors.\n\nHandle that with `deferred.gate`:\n\n```javascript\nvar fn = deferred.gate(function async() {\n\tvar def = deferred();\n\t// ..\n\treturn def.promise;\n}, 10);\n```\n\nIf there are already 10 concurrent tasks running `async` function invocation will be postponed into the queue and released when first of the running tasks will finish its job.\n\nAdditionally with third argument, we may limit number of postponed calls, so if there's more than _n_ of them rest is discarded. In below example, queue holds maximum 3 postponed calls, rest will be discarded.\n\n```javascript\nvar fn = deferred.gate(function async() { .. }, 10, 3);\n```\n\nIn following example we'll limit concurrent readFile calls when using deferred.map:\n\n```javascript\n// Open maximum 100 file descriptors at once\ndeferred.map(filenames, deferred.gate(function (filename) {\n\treturn readFile(filename, 'utf-8');\n}, 100))(function (result) {\n\t// result is an array of file's contents\n});\n```\n\n## Progress and other events\n\n__Promise objects are also an event emitters__. Deferred implementation is backed by cross-environment [event-emitter solution](https://github.com/medikoo/event-emitter)\n\nSimple Ajax file uploader example:\n\n```javascript\nvar ajaxFileUploader = function (url, data) {\n  var def = deferred();\n  var xhr = new XMLHttpRequest();\n\n  xhr.open('POST', url, true);\n  xhr.onload = def.resolve;\n  xhr.onerror = function () {\n    def.resolve(new Error(\"Could not upload files\"));\n  };\n  xhr.upload.onprogress = function (e) {\n    def.promise.emit('progress', e);\n  };\n  xhr.send(data);\n  return def.promise;\n};\n\nvar upload = ajaxFileUploader(formData);\nupload.on('progress', function () {\n  // process progress events\n});\nupload.done(function (e) {\n  // All files uploaded!\n});\n```\n### Streaming data partially\n\nAnother use case would be to provide obtained data partially on the go (stream like).\nImagine recursive directory reader that scans whole file system and provides filenames as it approaches them:\n\n```javascript\nvar reader = readdirDeep(rootPath); // reader promise is returned\nreader.on('data', function (someFilenames) {\n\t// Called many times during scan with obtained names\n});\nreader.done(function (allFilenames) {\n\t// File-system scan finished!\n});\n```\n\n## Promise extensions\n\nPromise objects are equipped with some useful extensions. All extension are optional but are loaded by default when `deferred` is loaded via `require('deferred')` import.\nWhen preparing client-side file (with help of e.g. [modules-webmake](https://github.com/medikoo/modules-webmake)) you are free to decide, which extensions you want to take (see source of `lib/index.js` on how to do that)\n\n### aside\n\nThird brother of `then` and `done`. Has same signature but neither extends chain nor ends it, instead splits it by returning promise on which it was invoked. Useful when we want to return promise, but on a side (in parallel) do something else with obtained value:\n\n```javascript\nvar x = deferred({ foo: 'bar' });\nvar promise = deferred({ foo: 'bar' });\n\nvar y = promise.aside(function (value) {\n\tconsole.log(value === x); // true\n});\nconsole.log(y === promise); // true\n```\n\n### catch\n\nSame as `then` but accepts only `onFail` callback.\n\n```javascript\n\nvar def = deferred(), promise2;\n\npromise2 = def.promise.catch(function () {\n  return 'Never mind';\n});\n\ndef.reject(new Error(\"Error\"));\n\npromise2.done(function (value) {\n  console.log(value); // Prints \"Never mind\"\n});\n```\n\n### cb\n\nConvert back to callback style. Useful if you want to process regular callback at the end of promise chain. Simple use case would be regular asynchronous function built internally with promises. `cb` also makes sure that your callback is not called immediately but in next tick earliest.\n\nWith cb we may build hybrid functions that do both, handle asynchronous callback and return promise:\n\n```javascript\nvar asyncFunction = function (x, y, callback)  {\n\tdeferred({ foo: x, bar: y }).cb(callback);\n});\n```\n\n### finally\n\nInvokes given callback when promise is either fulfilled or rejected\n\n```javascript\n\nvar prepare = function () { ... }\n  , cleanup = function () { ... }\n\nprepare();\npromise = asyncFn();\npromise.finally(cleanup);\n```\n\n### get\n\nTo directly get to object property use `get`\n\n```javascript\nvar promise = deferred({ foo: 'bar' });\n\npromise(function (obj) {\n\tconsole.log(obj.foo); // 'bar';\n})\n\npromise.get('foo')(function (value) {\n\tconsole.log(value); // 'bar'\n});\n```\n\nYou can get to nested properties as well:\n\n```javascript\nvar promise = deferred({ foo: { bar: 317 });\n\npromise(function (obj) {\n\tconsole.log(obj.foo.bar); // 317;\n})\n\npromise.get('foo', 'bar')(function (value) {\n\tconsole.log(value); // 317\n});\n```\n\n### invoke & invokeAsync\n\nSchedule function call on returned object\n\n```javascript\nvar promise = deferred({ foo: function (arg) { return arg*arg; } });\n\npromise.invoke('foo', 3)(function (result) {\n\tconsole.log(result); // 9\n});\n\n// For asynchronous functions use invokeAsync\nvar promise = deferred({ foo: function (arg, callback) {\n\tsetTimeout(function () {\n\t\tcallback(null, arg*arg);\n\t}, 100);\n} });\n\npromise.invokeAsync('foo', 3)(function (result) {\n\tconsole.log(result); // 9\n});\n```\n\n### map\n\nSee [promise aware version of Array's map](#map).\n\n### match\n\nIf promise expected value is a list that you want to match into function arguments then use `match`\n\n```javascript\nvar promise = deferred([2, 3]);\n\npromise.match(function (a, b) {\n\tconsole.log(a + b); // 5\n});\n```\n\n### reduce\n\nSee [promise aware version of Array's reduce](#reduce)\n\n### some\n\nSee [promise aware version of Array's some](#some)\n\n## Debugging\n\n### Monitoring unresolved promises\n\nIn properly constructed flow, there should be no promises that are never resolved.\nIf you want to be sure that it's not the case, or you suspect there are such issues, check whether deferred's monitor has something to say\n\n```javascript\ndeferred.monitor();\n```\n\nBy default monitor will log error for every promise that was not resolved in 5 seconds.\nYou can customize that timeout, and handle errors with your own listener:\n\n```javascript\ndeferred.monitor(10000, function (err) {\n  // Called for each promise not resolved in 10 seconds time\n});\n```\n\nThis extension affects performance and it's best not to use it in production environment\n\n### Usage statistics\n\nBeing able to see how many promises were initialized (and where) in our flow can be helpful to track application issues, it's also good way to confirm that constructed flow works as intended.\n\n```javascript\ndeferred.profile(); // Start collecting statistics\n\n//...\n\nvar stats = deferred.profileEnd(); // End profiling\nconsole.log(stats.log); // See readable output\n```\n\nExample log output:\n\n```\n------------------------------------------------------------\nDeferred/Promise usage statistics:\n\n104540 Total promises initialized\n104540 Initialized as Unresolved\n     0 Initialized as Resolved\n\nUnresolved promises were initialized at:\n 22590 at Object.module.exports.factory (/Users/medikoo/Projects/_packages/next/lib/fs/_memoize-watcher.js:21:10)\n 11553 at Object.IsIgnored.init (/Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:140:18)\n 11553 at module.exports.factory (/Users/medikoo/Projects/_packages/next/lib/fs/_memoize-watcher.js:21:10)\n  7854 at Object.Readdir.filterIgnored (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:434:23)\n  4619 at Object.module.exports.factory (/Users/medikoo/Projects/_packages/next/lib/fs/_memoize-watcher.js:21:10)\n  3927 at Object.Readdir.filterByType (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:222:15)\n  3927 at Object.Readdir.filterByType (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:236:15)\n  3927 at Object.self (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:164:12)\n  3927 at Object.Readdir.readdir (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:540:9)\n  3927 at Object.self (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:164:21)\n  3729 at directory (/Users/medikoo/Projects/_packages/next/lib/fs/_watch-alt.js:95:2)\n  2820 at Readdir.filterIgnored.promise.root (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:517:9)\n  2163 at basic (/Users/medikoo/Projects/_packages/next/lib/fs/is-gitrepo-root.js:14:8)\n  2159 at buildMap (/Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:117:22)\n  2159 at Object.FindRoot (/Users/medikoo/Projects/_packages/next/lib/fs/find-root.js:18:15)\n  1107 at Readdir.filterIgnored.promise.root (/Users/medikoo/Projects/_packages/next/lib/fs/readdir.js:527:11)\n   697 at Object.Map.addPaths (/Users/medikoo/Projects/_packages/next/lib/fs/_get-conf-file-map.js:107:19)\n   697 at readFile (/Users/medikoo/Projects/_packages/next/lib/fs/read-file.js:18:8)\n   697 at Object.readRulesWatch (/Users/medikoo/Projects/_packages/next/lib/fs/_get-conf-file-map.js:45:12)\n   247 at module.exports (/Users/medikoo/Projects/_packages/next/lib/fs/_watch.js:90:2)\n   247 at module.exports (/Users/medikoo/Projects/_packages/next/lib/fs/_watch.js:90:13)\n     1 at Object.Readdir.init (/Users/medikoo/Projects/_packa\n```\n\n__Using profiler significantly affects performance don't  use it in production environment.__\n\n## Performance\n\nPromises just by being rich objects introduce overhead over regular callbacks. If we do a lot asynchronous operations that are fast, performance of promise implementation that we rely on becomes a significant factor.\n\n_benchmark_ folder contains few plain test cases that compares Deferred to other popular promise implementations. Base of test is plain [lstat](http://nodejs.org/api/all.html#all_fs_lstat_path_callback) call to self file.\n\n_Example output taken under Node v0.10.20 on 2008 MBP._\n\n```\nPromise overhead (calling one after another) x10000:\n\n 1:   439ms  Base (plain Node.js lstat call)\n 2:   461ms  Kew: Dedicated wrapper\n 3:   609ms  Bluebird: Dedicated wrapper\n 4:   614ms  Bluebird: Promisify (generic wrapper)\n 5:   642ms  Deferred: Dedicated wrapper\n 6:   720ms  Deferred: Promisify (generic wrapper)\n 7:   792ms  When: Dedicated wrapper\n 8:  1068ms  Q: Dedicated wrapper\n 9:  1611ms  Q: nbind (generic wrapper)\n\nPromise overhead (concurrent calls) x10000:\n\n 1:   279ms  Base (plain Node.js lstat call)\n 2:   293ms  Bluebird: Promisify (generic wrapper) 2\n 3:   294ms  Bluebird: Dedicated wrapper\n 4:   329ms  Kew: Dedicated wrapper\n 5:   406ms  When: Dedicated wrapper\n 6:   430ms  Deferred: Dedicated wrapper\n 7:   598ms  Deferred: Promisify (generic wrapper)\n 8:   683ms  Deferred: Map + Promisify\n 9:  1610ms  Q: Dedicated wrapper\n10:  3645ms  Q: nbind (generic wrapper)\n```\n\n## Tests [![Build Status](https://travis-ci.org/medikoo/deferred.png?branch=master)](https://travis-ci.org/medikoo/deferred)\n\n__Covered by over 300 hundred unit tests__\n\n\t$ npm test\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/medikoo/deferred",
  "_id": "deferred@0.6.6",
  "dist": {
    "shasum": "dd67b48d87c379f65bd8c2fdf7ced840c8a6d76c"
  },
  "_resolved": "https://registry.npmjs.org/deferred/-/deferred-0.6.6.tgz",
  "_from": "deferred@latest"
}
