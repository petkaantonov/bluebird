{
  "name": "rsvp",
  "version": "2.0.4",
  "description": "A lightweight library that provides tools for organizing asynchronous code",
  "main": "dist/commonjs/main.js",
  "directories": {
    "lib": "lib"
  },
  "devDependencies": {
    "jshint": "~0.9",
    "grunt": "~0.4.1",
    "grunt-microlib": "git://github.com/thomasboyt/grunt-microlib.git",
    "promises-aplus-tests": "~1.3.1",
    "grunt-browserify": "~1.0.2",
    "grunt-mocha-phantomjs": "~0.3.0",
    "grunt-mocha-test": "~0.5.0",
    "grunt-s3": "~0.2.0-alpha.2"
  },
  "scripts": {
    "test": "grunt test",
    "lint": "jshint lib",
    "prepublish": "grunt build"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tildeio/rsvp.js.git"
  },
  "bugs": {
    "url": "https://github.com/tildeio/rsvp.js/issues"
  },
  "keywords": [
    "promises",
    "futures",
    "events"
  ],
  "author": {
    "name": "Tilde, Inc."
  },
  "license": "MIT",
  "readme": "# RSVP.js  [![Build Status](https://secure.travis-ci.org/tildeio/rsvp.js.png?branch=master)](http://travis-ci.org/tildeio/rsvp.js)\n\nRSVP.js provides simple tools for organizing asynchronous code.\n\nSpecifically, it is a tiny implementation of Promises/A+ and a\nmixin for turning objects into event targets.\n\nIt works in node and the browser.\n\n## downloads\n\n- [rsvp-latest](http://rsvpjs-builds.s3.amazonaws.com/rsvp-latest.js)\n- [rsvp-latest (amd)](http://rsvpjs-builds.s3.amazonaws.com/rsvp-latest.amd.js)\n\n## Promises\n\n`RSVP.Promise` is an implementation of\n[Promises/A+](http://promises-aplus.github.com/promises-spec/) that passes the\n[test suite](https://github.com/promises-aplus/promises-tests).\n\nIt delivers all promises asynchronously, even if the value is already\navailable, to help you write consistent code that doesn't change if the\nunderlying data provider changes from synchronous to asynchronous.\n\nIt is compatible with [TaskJS](http://taskjs.org/), a library by Dave\nHerman of Mozilla that uses ES6 generators to allow you to write\nsynchronous code with promises. It currently works in Firefox, and will\nwork in any browser that adds support for ES6 generators. See the\nsection below on TaskJS for more information.\n\n### Basic Usage\n\n```javascript\nvar promise = new RSVP.Promise(function(resolve, reject){\n  // succeed\n  resolve(value);\n  // or reject\n  reject(error);\n});\n\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n```\n\nOnce a promise has been resolved or rejected, it cannot be resolved or\nrejected again.\n\nHere is an example of a simple XHR2 wrapper written using RSVP.js:\n\n```javascript\nvar getJSON = function(url) {\n  var promise = new RSVP.Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n    function handler() {\n      if (this.readyState === this.DONE) {\n        if (this.status === 200) { resolve(this.response); }\n        else { reject(this); }\n      }\n    };\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  // continue\n}, function(error) {\n  // handle errors\n});\n```\n\n### Chaining\n\nOne of the really awesome features of Promises/A+ promises are that they\ncan be chained together. In other words, the return value of the first\nresolve handler will be passed to the second resolve handler.\n\nIf you return a regular value, it will be passed, as is, to the next\nhandler.\n\n```javascript\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // proceed\n});\n```\n\nThe really awesome part comes when you return a promise from the first\nhandler:\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  // save off post\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n});\n```\n\nThis allows you to flatten out nested callbacks, and is the main feature\nof promises that prevents \"rightward drift\" in programs with a lot of\nasynchronous code.\n\nErrors also propagate:\n\n```javascript\ngetJSON(\"/posts.json\").then(function(posts) {\n\n}).then(null, function(error) {\n  // since no rejection handler was passed to the\n  // first `.then`, the error propagates.\n});\n```\n\nYou can use this to emulate `try/catch` logic in synchronous code.\nSimply chain as many resolve callbacks as a you want, and add a failure\nhandler at the end to catch errors.\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n}).then(null, function(error) {\n  // handle errors in either of the two requests\n});\n```\n\nYou can also use `fail` for error handling, which is a shortcut for\n`then(null, rejection)`, like so:\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).fail(function(error) {\n  // handle errors\n});\n```\n\n## Arrays of promises\n\nSometimes you might want to work with many promises at once. If you\npass an array of promises to the `all()` method it will return a new\npromise that will be fulfilled when all of the promises in the array\nhave been fulfilled; or rejected immediately if any promise in the array\nis rejected.\n\n```javascript\nvar postIds = [2, 3, 5, 7, 11, 13];\nvar promises = [];\n\nfor(var i = 0; i < postIds.length; i++) {\n\tpromises.push(getJSON(\"/post/\" + postIds[i] + \".json\"));\n}\n\nRSVP.all(promises).then(function(posts) {\n\t// posts contains an array of results for the given promises\n});\n```\n\n## TaskJS\n\nThe [TaskJS](http://taskjs.org/) library makes it possible to take\npromises-oriented code and make it synchronous using ES6 generators.\n\nLet's review an earlier example:\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // proceed with access to posts and comments\n}).then(null, function(error) {\n  // handle errors in either of the two requests\n});\n```\n\nWithout any changes to the implementation of `getJSON`, you could write\nthe following code with TaskJS:\n\n```javascript\nspawn(function *() {\n  try {\n    var post = yield getJSON(\"/post/1.json\");\n    var comments = yield getJSON(post.commentURL);\n  } catch(error) {\n    // handle errors\n  }\n});\n```\n\nIn the above example, `function *` is new syntax in ES6 for\n[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators).\nInside a generator, `yield` pauses the generator, returning control to\nthe function that invoked the generator. In this case, the invoker is a\nspecial function that understands the semantics of Promises/A, and will\nautomatically resume the generator as soon as the promise is resolved.\n\nThe cool thing here is the same promises that work with current\nJavaScript using `.then` will work seamlessly with TaskJS once a browser\nhas implemented it!\n\n## Event Target\n\nRSVP also provides a mixin that you can use to convert any object into\nan event target. The promises implementation uses `RSVP.EventTarget`, so\n`RSVP` exposes it for your own use.\n\n### Basic Usage\n\nThe basic usage of `RSVP.EventTarget` is to mix it into an object, then\nuse `on` and `trigger` to register listeners and trigger them.\n\n```javascript\nvar object = {};\n\nRSVP.EventTarget.mixin(object);\n\nobject.on(\"finished\", function(event) {\n  // handle event\n});\n\nobject.trigger(\"finished\", { detail: value });\n```\n\n### Prototypes\n\nYou can mix `RSVP.EventTarget` into a prototype and it will work as\nexpected.\n\n```javascript\nvar Person = function() {};\nRSVP.EventTarget.mixin(Person.prototype);\n\nvar yehuda = new Person();\nvar tom = new Person();\n\nyehuda.on(\"poke\", function(event) {\n  console.log(\"Yehuda says OW\");\n});\n\ntom.on(\"poke\", function(event) {\n  console.log(\"Tom says OW\");\n});\n\nyehuda.trigger(\"poke\");\ntom.trigger(\"poke\");\n```\n\nThe example will work as expected. If you mix `RSVP.EventTarget` into a\nconstructor's prototype, each instance of that constructor will get its\nown callbacks.\n\n## Building & Testing\n\nThis package uses the [grunt-microlib](https://github.com/thomasboyt/grunt-microlib) package for building.\n\nCustom tasks:\n\n* `grunt test` - Run Mocha tests through Node and PhantomJS.\n* `grunt test:phantom` - Run Mocha tests through PhantomJS (browser build).\n* `grunt test:node` - Run Mocha tests through Node (CommonJS build).\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/tildeio/rsvp.js",
  "_id": "rsvp@2.0.4",
  "_from": "rsvp@latest"
}
